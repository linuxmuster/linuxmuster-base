#!/bin/sh
#
# /usr/sbin/linuxmuster-backup
# wrapper script for serverbackup with mondo
# schmitt@lmz-bw.de
#


# source linuxmuster defaults
. /usr/share/linuxmuster/config/dist.conf || exit 1


# source helperfunctions
. $HELPERFUNCTIONS || exit 1


# default values
mondocache=/var/cache/mondo-archive
cachefiles="difflevel.0 mondo-restore.cfg mountlist.txt"
verify=yes
isoprefix=server
mediasize=650
excludedirs="/var/lib/uml/ipcop /var/tmp"
compression=3
keepfull=1
keepinc=7


# read config
[ -f /etc/linuxmuster/backup.conf ] && . /etc/linuxmuster/backup.conf


# parsing parameters
getopt $*


usage() {
  echo
  echo "Usage: linuxmuster-backup --full|--diff|--inc [options]"
  echo
  echo "Options:"
  echo "--backupdevice=device                : device is a hd partition or a nfs share,"
  echo "                                       e.g. /dev/sdb1 or 10.16.1.10:/home/nfs".
  echo "--mountpoint=directory               : directory where the device is mounted."
  echo "--restoremethod=hd|nfs               : where you plan to restore from."
  echo "--ipcop=yes|no                       : whether to archive current ipcop settings."
  echo "--verify=yes|no                      : whether to verify data after backup."
  echo "--isoprefix=server                   : string which is used as a prefix for"
  echo "                                       the iso files and the folder."
  echo "--mediasize=4430                     : size of the iso files in mb."
  echo "--excludedirs=dir1,dir2,...          : directories to exclude from backup."
  echo "--includedirs=dir1,dir2,...          : directories to include in backup,"
  echo "                                       if not set the whole file system will be backed up."
  echo "--services=all|service1,service2,... : list of services in the current runlevel which"
  echo "                                       have to be stopped before backup begins,"
  echo "                                       <all> stops all services in the current runlevel,"
  echo "                                       if not set no service will be stopped."
  echo "--compression=3                      : compression level (0-9), 0 means no compression."
  echo "--unmount=yes|no                     : whether to unmount the backupdevice after backup."
  echo "--keepfull=1                         : how many full backup sets to keep"
  echo "--keepdiff=1                         : how many differential backup sets to keep."
  echo "--keepinc=7                          : how many incremental backup sets to keep."
  echo "                                       keep values have to be greater than 0."
  echo
  exit 1
}


# test options
[[ -n "$full" && -n "$inc" ]] && usage
[[ -n "$full" && -n "$diff" ]] && usage
[[ -n "$inc" && -n "$diff" ]] && usage
[[ -z "$backupdevice" || -z "$mountpoint" ]] && usage


# set mondoarchive parameter
if [ -n "$full" ]; then

	isinteger $keepfull || usage
	btypeparam="-O"
	btype=full
	msg="Full"

elif [ -n "$diff" ]; then

	isinteger $keepdiff || usage
	btypeparam="-D -O"
	btype=diff
	msg="Differential"

elif [ -n "$inc" ]; then

	isinteger $keepinc || usage
	btypeparam="-D -O"
	btype=inc
	msg="Incremental"

else

	usage

fi
[ "$verify" != "no" ] && btypeparam="${btypeparam} -V"
bfolder=${DATETIME}_${btype}


# warning
echo "$msg backup starts in 5 seconds! Press CTRL-C to cancel!"
sleep 5


# check if i am already running
mypid=$$
mypidfile=/var/run/linuxmuster-backup.pid
if [ -e "$mypidfile" ]; then
    echo "There is already a linuxmuster-backup process running! Exiting!"
    echo "If this is not correct you have to delete $mypidfile!"
    exit 0
fi
echo "$mypid" > $mypidfile


# exit with error
error() {
	echo "An error occured! Exiting!"
	rm $mypidfile
	exit 1
} # error


# create mountpoint if necessary
[ -d "$mountpoint" ] || mkdir -p $mountpoint


# check if backupdevice is already mounted
if mount | grep "$backupdevice" | grep -q "$mountpoint"; then

    echo "$backupdevice is already mounted on $mountpoint!"
    mounted=yes

fi


# mount if necessary and set params depending on restoremethod
case $restoremethod in

    hd)
	if [ -z "$mounted" ]; then
	    echo "Trying to mount $backupdevice on $mountpoint ..."
	    mount $backupdevice $mountpoint || error
	fi
	rtypeparam="-i"
	target=$mountpoint/$isoprefix/$bfolder
	;;

    nfs)
	if [ -z "$mounted" ]; then
	    echo "Trying to mount $backupdevice on $mountpoint ..."
	    mount -t nfs -o rsize=8192,wsize=8192 $backupdevice $mountpoint || error
	fi
	rtypeparam="-n $backupdevice"
	target=$isoprefix/$bfolder
	;;

    *)
	echo "Unknown restore method!"
	error
	;;

esac
[ -z "$mounted" ] && echo "$backupdevice successfully mounted on $mountpoint!"


# storing runlevel
rl=`runlevel | awk '{ print $2 }'`


# converting lists
excludedirs=${excludedirs//,/ }
includedirs=${includedirs//,/ }
services=${services//,/ }


# temp file for sorted services
stmp=/var/tmp/tmp.services.$mypid
[ -e "$stmp" ] && rm $stmp


# included dirs?
[ -z "$includedirs" ] && includedirs=/


# backup ipcop settings
[ "$ipcop" = "yes" ] && /usr/share/linuxmuster-ipcop/backup-settings.sh


# shut down services
if [ -n "$services" ]; then

	echo "Shutting down services ..."

	if [ "$services" = "all" ]; then

		for s in `ls -r /etc/rc${rl}.d/S*`; do

			$s stop

		done
	
	else

		for s in $services; do

			[ -e /etc/rc${rl}.d/S??${s} ] && echo /etc/rc${rl}.d/S??${s} >> $stmp

		done

		if [ -s "$stmp" ]; then

			for s in `sort -r $stmp`; do

				$s stop

			done

		else

			echo "No services to shut down!"

		fi

	fi

fi


# start archiving process
echo
echo "Starting $msg backup process with following options:"
echo "  backupdevice=$backupdevice"
echo "  mountpoint=$mountpoint"
echo "  restoremethod=$restoremethod"
echo "  ipcop=$ipcop"
echo "  verify=$verify"
echo "  services=$servcies"
echo "  isoprefix=$isoprefix"
echo "  bfolder=$bfolder"
echo "  includedirs=$includedirs"
echo "  excludedirs=$excludedirs"
echo "  mediasize=$mediasize"
echo "  compression=$compression"
echo "  unmount=$unmount"
echo "  btypeparam=$btypeparam"
echo "  rtypeparam=$rtypeparam"
echo "  target=$target"
echo


# storing backup time in unix format
backuptime=`date +%s`


# determine last backup set
case $btype in

	diff)
		# difflevel of last full backup
		if sets=`ls -dr $mountpoint/$isoprefix/*-*_full`; then

			lastset=`echo $sets | awk '{ print $1 }'`
			echo "Found last full backup set in $lastset."
			
		else

			echo "Last full backup set not found!"

		fi
		;;

	inc)
		# difflevel of last backup (full, diff or inc)
		if sets=`ls -dr $mountpoint/$isoprefix/*-*_* | grep -G _[dfi][inu][cfl]`; then

			lastset=`echo $sets | awk '{ print $1 }'`
			echo "Found last backup set in $lastset."
			
		else

			echo "Last backup set not found!"

		fi
		;;

	*)
		;;

esac


# restore mondo-archive cache if no full backup
if [ "$btype" != "full" ]; then

	if [ -d "$lastset/cache" ]; then

		# test if all cachefiles are present
		echo "Testing cachefiles in $lastset/cache ..."
		STATUS=0
		for i in $cachefiles; do
			[ -e "$lastset/cache/$i" ] || STATUS=1
		done

		if [ "$STATUS" -eq 0 ]; then

			echo "Restoring cache from $lastset/cache ..."
			rsync -a --delete $lastset/cache/ $mondocache/

		else

			echo "At least one of $cachefiles is missing!"
			echo "Cannot restore cache!"

		fi

	else

		echo "$lastset/cache does not exist! Cannot restore cache!"

	fi

fi


# create backup folder if necessary
[ -d "$mountpoint/$isoprefix/$bfolder/cache" ] || mkdir -p $mountpoint/$isoprefix/$bfolder/cache


# starting mondoarchive
nice -n 19 mondoarchive $btypeparam -p $isoprefix $rtypeparam -I "$includedirs" -E "$mountpoint $adminisodir $excludedirs" -N -d $target -s ${mediasize}m -F -$compression -L
status=$?


# if mondoarchive exits cleanly
if [ "$status" = "0" ]; then

	echo "mondoarchive finished successfully!"

	# store cache files
	echo "Storing cache to $mountpoint/$isoprefix/$bfolder/cache ..."
	rsync -a --delete $mondocache/ $mountpoint/$isoprefix/$bfolder/cache/

	case $btype in

		full)
			# copying mondorescue.iso to backup folder if it is a full backup
			echo "Copying mondorescue.iso to $mountpoint/$isoprefix/$bfolder ..."
			cp -a /root/images/mindi/mondorescue.iso $mountpoint/$isoprefix/$bfolder

			setstokeep=$keepfull
			;;

		diff)
			setstokeep=$keepdiff
			# store difflevel
			echo $backuptime > $mountpoint/$isoprefix/$bfolder/cache/difflevel.0
			;;

		inc)
			setstokeep=$keepinc
			echo $backuptime > $mountpoint/$isoprefix/$bfolder/cache/difflevel.0
			;;

	esac

	# cleaning up backup sets
	if sets=`ls -dr $mountpoint/$isoprefix/*_$btype`; then

		n=1
		echo "Keeping $setstokeep $btype backup sets."

		for s in $sets; do

			if [ "$n" -gt "$setstokeep" ]; then

				echo "Deleting $btype backup set "$s" ..."
				rm -rf $s

			fi

			let n+=1

		done

	fi

else

	echo "Mondoarchive finished with error!"

	if [ -d "$mountpoint/$isoprefix/$bfolder" ]; then

		echo "Removing $mountpoint/$isoprefix/$bfolder ..."
		rm -rf $mountpoint/$isoprefix/$bfolder

	fi

fi # status = 0


# cleaning up tmp dirs
for i in $mountpoint /home; do

	echo "Cleaning up tmp dirs on $i ..."
	rm -rf $i/mondo.scratch.*
	rm -rf $i/tmp.mondo.*

done


# linking backup mountpoint to administrator's home
[ -L "$adminhome/_backup" ] && rm $adminhome/_backup
ln -s $mountpoint $adminhome/_backup


# unmounting backup media if requested
if [ "$unmount" = "yes" ]; then

    echo "Trying to unmount $backupdevice as requested ..."
    umount $backupdevice && echo "Successfully unmounted $backupdevice!"

else

    echo "Not unmounting $backupdevice as requested!"

fi


# start services again
if [ -n "$services" ]; then

	echo "Starting services again ..."

	if [ "$services" = "all" ]; then

		for s in /etc/rc${rl}.d/S*; do

			$s start

		done
	
	else

		if [ -s "$stmp" ]; then

			for s in `sort $stmp`; do

				$s start

			done

		else

			echo "No services to start!"

		fi


	fi

fi


# delete temp files
[ -e "$stmp" ] && rm $stmp
rm $mypidfile


# logging exit status
echo $status > $LOGDIR/linuxmuster-backup.status


# all done
if [ "$status" = "0" ]; then
	echo "Done! :-)"
else
	echo "Done with mondoarchive error! :-("
fi


exit $status
